{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\n\nvar _regeneratorRuntime = require(\"D:\\\\Portfolio\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\Portfolio\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"D:\\\\Portfolio\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar gaxios_1 = require(\"gaxios\");\n\nvar jsonBigint = require('json-bigint');\n\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.BASE_URL = exports.HOST_ADDRESS + exports.BASE_PATH;\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.SECONDARY_BASE_URL = exports.SECONDARY_HOST_ADDRESS + exports.BASE_PATH;\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze(_defineProperty({}, exports.HEADER_NAME, exports.HEADER_VALUE)); // Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\n\nfunction validate(options) {\n  Object.keys(options).forEach(function (key) {\n    switch (key) {\n      case 'params':\n      case 'property':\n      case 'headers':\n        break;\n\n      case 'qs':\n        throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n\n      default:\n        throw new Error(\"'\".concat(key, \"' is not a valid configuration option.\"));\n    }\n  });\n}\n\nfunction metadataAccessor(_x, _x2) {\n  return _metadataAccessor.apply(this, arguments);\n}\n\nfunction _metadataAccessor() {\n  _metadataAccessor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, options) {\n    var noResponseRetries,\n        fastFail,\n        property,\n        requestMethod,\n        res,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            noResponseRetries = _args.length > 2 && _args[2] !== undefined ? _args[2] : 3;\n            fastFail = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;\n            options = options || {};\n\n            if (typeof options === 'string') {\n              options = {\n                property: options\n              };\n            }\n\n            property = '';\n\n            if (typeof options === 'object' && options.property) {\n              property = '/' + options.property;\n            }\n\n            validate(options);\n            _context.prev = 7;\n            requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n            _context.next = 11;\n            return requestMethod({\n              url: \"\".concat(exports.BASE_URL, \"/\").concat(type).concat(property),\n              headers: Object.assign({}, exports.HEADERS, options.headers),\n              retryConfig: {\n                noResponseRetries: noResponseRetries\n              },\n              params: options.params,\n              responseType: 'text',\n              timeout: requestTimeout()\n            });\n\n          case 11:\n            res = _context.sent;\n\n            if (!(res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE)) {\n              _context.next = 16;\n              break;\n            }\n\n            throw new Error(\"Invalid response from metadata service: incorrect \".concat(exports.HEADER_NAME, \" header.\"));\n\n          case 16:\n            if (res.data) {\n              _context.next = 18;\n              break;\n            }\n\n            throw new Error('Invalid response from the metadata service');\n\n          case 18:\n            if (!(typeof res.data === 'string')) {\n              _context.next = 25;\n              break;\n            }\n\n            _context.prev = 19;\n            return _context.abrupt(\"return\", jsonBigint.parse(res.data));\n\n          case 23:\n            _context.prev = 23;\n            _context.t0 = _context[\"catch\"](19);\n\n          case 25:\n            return _context.abrupt(\"return\", res.data);\n\n          case 28:\n            _context.prev = 28;\n            _context.t1 = _context[\"catch\"](7);\n\n            if (_context.t1.response && _context.t1.response.status !== 200) {\n              _context.t1.message = \"Unsuccessful response status code. \".concat(_context.t1.message);\n            }\n\n            throw _context.t1;\n\n          case 32:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[7, 28], [19, 23]]);\n  }));\n  return _metadataAccessor.apply(this, arguments);\n}\n\nfunction fastFailMetadataRequest(_x3) {\n  return _fastFailMetadataRequest.apply(this, arguments);\n} // tslint:disable-next-line no-any\n\n\nfunction _fastFailMetadataRequest() {\n  _fastFailMetadataRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n    var secondaryOptions, responded, r1, r2;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            secondaryOptions = Object.assign(Object.assign({}, options), {\n              url: options.url.replace(exports.BASE_URL, exports.SECONDARY_BASE_URL)\n            }); // We race a connection between DNS/IP to metadata server. There are a couple\n            // reasons for this:\n            //\n            // 1. the DNS is slow in some GCP environments; by checking both, we might\n            //    detect the runtime environment signficantly faster.\n            // 2. we can't just check the IP, which is tarpitted and slow to respond\n            //    on a user's local machine.\n            //\n            // Additional logic has been added to make sure that we don't create an\n            // unhandled rejection in scenarios where a failure happens sometime\n            // after a success.\n            //\n            // Note, however, if a failure happens prior to a success, a rejection should\n            // occur, this is for folks running locally.\n            //\n\n            responded = false;\n            r1 = gaxios_1.request(options).then(function (res) {\n              responded = true;\n              return res;\n            }).catch(function (err) {\n              if (responded) {\n                return r2;\n              } else {\n                responded = true;\n                throw err;\n              }\n            });\n            r2 = gaxios_1.request(secondaryOptions).then(function (res) {\n              responded = true;\n              return res;\n            }).catch(function (err) {\n              if (responded) {\n                return r1;\n              } else {\n                responded = true;\n                throw err;\n              }\n            });\n            return _context2.abrupt(\"return\", Promise.race([r1, r2]));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fastFailMetadataRequest.apply(this, arguments);\n}\n\nfunction instance(options) {\n  return metadataAccessor('instance', options);\n}\n\nexports.instance = instance; // tslint:disable-next-line no-any\n\nfunction project(options) {\n  return metadataAccessor('project', options);\n}\n\nexports.project = project;\n/*\n * How many times should we retry detecting GCP environment.\n */\n\nfunction detectGCPAvailableRetries() {\n  return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;\n}\n/**\n * Determine if the metadata server is currently available.\n */\n\n\nvar cachedIsAvailableResponse;\n\nfunction isAvailable() {\n  return _isAvailable.apply(this, arguments);\n}\n\nfunction _isAvailable() {\n  _isAvailable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n\n            // If a user is instantiating several GCP libraries at the same time,\n            // this may result in multiple calls to isAvailable(), to detect the\n            // runtime environment. We use the same promise for each of these calls\n            // to reduce the network load.\n            if (cachedIsAvailableResponse === undefined) {\n              cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), true);\n            }\n\n            _context3.next = 4;\n            return cachedIsAvailableResponse;\n\n          case 4:\n            return _context3.abrupt(\"return\", true);\n\n          case 7:\n            _context3.prev = 7;\n            _context3.t0 = _context3[\"catch\"](0);\n\n            if (process.env.DEBUG_AUTH) {\n              console.info(_context3.t0);\n            }\n\n            if (!(_context3.t0.type === 'request-timeout')) {\n              _context3.next = 14;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", false);\n\n          case 14:\n            if (!(_context3.t0.code && ['EHOSTDOWN', 'EHOSTUNREACH', 'ENETUNREACH', 'ENOENT', 'ENOTFOUND', 'ECONNREFUSED'].includes(_context3.t0.code))) {\n              _context3.next = 18;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", false);\n\n          case 18:\n            if (!(_context3.t0.response && _context3.t0.response.status === 404)) {\n              _context3.next = 20;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", false);\n\n          case 20:\n            throw _context3.t0;\n\n          case 21:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 7]]);\n  }));\n  return _isAvailable.apply(this, arguments);\n}\n\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */\n\nfunction resetIsAvailableCache() {\n  cachedIsAvailableResponse = undefined;\n}\n\nexports.resetIsAvailableCache = resetIsAvailableCache;\n\nfunction requestTimeout() {\n  // In testing, we were able to reproduce behavior similar to\n  // https://github.com/googleapis/google-auth-library-nodejs/issues/798\n  // by making many concurrent network requests. Requests do not actually fail,\n  // rather they take significantly longer to complete (and we hit our\n  // default 3000ms timeout).\n  //\n  // This logic detects a GCF environment, using the documented environment\n  // variables K_SERVICE and FUNCTION_NAME:\n  // https://cloud.google.com/functions/docs/env-var and, in a GCF environment\n  // eliminates timeouts (by setting the value to 0 to disable).\n  return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3000;\n}\n\nexports.requestTimeout = requestTimeout;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gaxios_1 = require(\"gaxios\");\nconst jsonBigint = require('json-bigint');\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.BASE_URL = exports.HOST_ADDRESS + exports.BASE_PATH;\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.SECONDARY_BASE_URL = exports.SECONDARY_HOST_ADDRESS + exports.BASE_PATH;\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n    Object.keys(options).forEach(key => {\n        switch (key) {\n            case 'params':\n            case 'property':\n            case 'headers':\n                break;\n            case 'qs':\n                throw new Error(`'qs' is not a valid configuration option. Please use 'params' instead.`);\n            default:\n                throw new Error(`'${key}' is not a valid configuration option.`);\n        }\n    });\n}\nasync function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { property: options };\n    }\n    let property = '';\n    if (typeof options === 'object' && options.property) {\n        property = '/' + options.property;\n    }\n    validate(options);\n    try {\n        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n        const res = await requestMethod({\n            url: `${exports.BASE_URL}/${type}${property}`,\n            headers: Object.assign({}, exports.HEADERS, options.headers),\n            retryConfig: { noResponseRetries },\n            params: options.params,\n            responseType: 'text',\n            timeout: requestTimeout(),\n        });\n        // NOTE: node.js converts all incoming headers to lower case.\n        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n            throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n        }\n        else if (!res.data) {\n            throw new Error('Invalid response from the metadata service');\n        }\n        if (typeof res.data === 'string') {\n            try {\n                return jsonBigint.parse(res.data);\n            }\n            catch (_a) {\n                /* ignore */\n            }\n        }\n        return res.data;\n    }\n    catch (e) {\n        if (e.response && e.response.status !== 200) {\n            e.message = `Unsuccessful response status code. ${e.message}`;\n        }\n        throw e;\n    }\n}\nasync function fastFailMetadataRequest(options) {\n    const secondaryOptions = Object.assign(Object.assign({}, options), { url: options.url.replace(exports.BASE_URL, exports.SECONDARY_BASE_URL) });\n    // We race a connection between DNS/IP to metadata server. There are a couple\n    // reasons for this:\n    //\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\n    //    detect the runtime environment signficantly faster.\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\n    //    on a user's local machine.\n    //\n    // Additional logic has been added to make sure that we don't create an\n    // unhandled rejection in scenarios where a failure happens sometime\n    // after a success.\n    //\n    // Note, however, if a failure happens prior to a success, a rejection should\n    // occur, this is for folks running locally.\n    //\n    let responded = false;\n    const r1 = gaxios_1.request(options)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r2;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    const r2 = gaxios_1.request(secondaryOptions)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r1;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    return Promise.race([r1, r2]);\n}\n// tslint:disable-next-line no-any\nfunction instance(options) {\n    return metadataAccessor('instance', options);\n}\nexports.instance = instance;\n// tslint:disable-next-line no-any\nfunction project(options) {\n    return metadataAccessor('project', options);\n}\nexports.project = project;\n/*\n * How many times should we retry detecting GCP environment.\n */\nfunction detectGCPAvailableRetries() {\n    return process.env.DETECT_GCP_RETRIES\n        ? Number(process.env.DETECT_GCP_RETRIES)\n        : 0;\n}\n/**\n * Determine if the metadata server is currently available.\n */\nlet cachedIsAvailableResponse;\nasync function isAvailable() {\n    try {\n        // If a user is instantiating several GCP libraries at the same time,\n        // this may result in multiple calls to isAvailable(), to detect the\n        // runtime environment. We use the same promise for each of these calls\n        // to reduce the network load.\n        if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), true);\n        }\n        await cachedIsAvailableResponse;\n        return true;\n    }\n    catch (err) {\n        if (process.env.DEBUG_AUTH) {\n            console.info(err);\n        }\n        if (err.type === 'request-timeout') {\n            // If running in a GCP environment, metadata endpoint should return\n            // within ms.\n            return false;\n        }\n        else if (err.code &&\n            [\n                'EHOSTDOWN',\n                'EHOSTUNREACH',\n                'ENETUNREACH',\n                'ENOENT',\n                'ENOTFOUND',\n                'ECONNREFUSED',\n            ].includes(err.code)) {\n            // Failure to resolve the metadata service means that it is not available.\n            return false;\n        }\n        else if (err.response && err.response.status === 404) {\n            return false;\n        }\n        // Throw unexpected errors.\n        throw err;\n    }\n}\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */\nfunction resetIsAvailableCache() {\n    cachedIsAvailableResponse = undefined;\n}\nexports.resetIsAvailableCache = resetIsAvailableCache;\nfunction requestTimeout() {\n    // In testing, we were able to reproduce behavior similar to\n    // https://github.com/googleapis/google-auth-library-nodejs/issues/798\n    // by making many concurrent network requests. Requests do not actually fail,\n    // rather they take significantly longer to complete (and we hit our\n    // default 3000ms timeout).\n    //\n    // This logic detects a GCF environment, using the documented environment\n    // variables K_SERVICE and FUNCTION_NAME:\n    // https://cloud.google.com/functions/docs/env-var and, in a GCF environment\n    // eliminates timeouts (by setting the value to 0 to disable).\n    return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3000;\n}\nexports.requestTimeout = requestTimeout;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}